Function.prototype.bind =
  Function.prototype.bind ||
  function (target) {
    var self = this;
    return function (args) {
      if (!(args instanceof Array)) {
        args = [args];
      }
      self.apply(target, args);
    };
  };
(function () {
  if (
    typeof window.Element === "undefined" ||
    "classList" in document.documentElement
  ) {
    return;
  }
  var prototype = Array.prototype,
    push = prototype.push,
    splice = prototype.splice,
    join = prototype.join;
  function DOMTokenList(el) {
    this.el = el;
    var classes = el.className.replace(/^\s+|\s+$/g, "").split(/\s+/);
    for (var i = 0; i < classes.length; i++) {
      push.call(this, classes[i]);
    }
  }
  DOMTokenList.prototype = {
    add: function (token) {
      if (this.contains(token)) return;
      push.call(this, token);
      this.el.className = this.toString();
    },
    contains: function (token) {
      return this.el.className.indexOf(token) != -1;
    },
    item: function (index) {
      return this[index] || null;
    },
    remove: function (token) {
      if (!this.contains(token)) return;
      for (var i = 0; i < this.length; i++) {
        if (this[i] == token) break;
      }
      splice.call(this, i, 1);
      this.el.className = this.toString();
    },
    toString: function () {
      return join.call(this, " ");
    },
    toggle: function (token) {
      if (!this.contains(token)) {
        this.add(token);
      } else {
        this.remove(token);
      }
      return this.contains(token);
    },
  };
  window.DOMTokenList = DOMTokenList;
  function defineElementGetter(obj, prop, getter) {
    if (Object.defineProperty) {
      Object.defineProperty(obj, prop, { get: getter });
    } else {
      obj.__defineGetter__(prop, getter);
    }
  }
  defineElementGetter(HTMLElement.prototype, "classList", function () {
    return new DOMTokenList(this);
  });
})();
(function () {
  var lastTime = 0;
  var vendors = ["webkit", "moz"];
  for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
    window.requestAnimationFrame = window[vendors[x] + "RequestAnimationFrame"];
    window.cancelAnimationFrame =
      window[vendors[x] + "CancelAnimationFrame"] ||
      window[vendors[x] + "CancelRequestAnimationFrame"];
  }
  if (!window.requestAnimationFrame) {
    window.requestAnimationFrame = function (callback, element) {
      var currTime = new Date().getTime();
      var timeToCall = Math.max(0, 16 - (currTime - lastTime));
      var id = window.setTimeout(function () {
        callback(currTime + timeToCall);
      }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };
  }
  if (!window.cancelAnimationFrame) {
    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };
  }
})();
(function () {
  "use strict";
  var undef_type = "undefined",
    string_type = "string",
    nav = self.navigator,
    String_ctr = String,
    has_own_prop = Object.prototype.hasOwnProperty,
    load_queues = {},
    localizations = {},
    FALSE = !1,
    TRUE = !0,
    l10n_js_media_type =
      /^\s*application\/(?:vnd\.oftn\.|x-)?l10n\+json\s*(?:$|;)/i,
    XHR,
    $locale = "locale",
    $default_locale = "defaultLocale",
    $to_locale_string = "toLocaleString",
    $to_lowercase = "toLowerCase",
    array_index_of =
      Array.prototype.indexOf ||
      function (item) {
        var len = this.length,
          i = 0;
        for (; i < len; i++) {
          if (i in this && this[i] === item) {
            return i;
          }
        }
        return -1;
      },
    request_JSON = function (uri) {
      var req = new XHR();
      req.open("GET", uri, FALSE);
      req.send(null);
      if (req.status !== 200) {
        setTimeout(function () {
          var l10n_err = new Error("Unable to load localization data: " + uri);
          l10n_err.name = "Localization Error";
          throw l10n_err;
        }, 0);
        return {};
      } else {
        return JSON.parse(req.responseText);
      }
    },
    load = (String_ctr[$to_locale_string] = function (data) {
      if (arguments.length > 0 && typeof data !== "number") {
        if (typeof data === string_type) {
          load(request_JSON(data));
        } else if (data === FALSE) {
          localizations = {};
        } else {
          var locale, localization, message;
          for (locale in data) {
            if (has_own_prop.call(data, locale)) {
              localization = data[locale];
              locale = locale[$to_lowercase]();
              if (!(locale in localizations) || localization === FALSE) {
                localizations[locale] = {};
              }
              if (localization === FALSE) {
                continue;
              }
              if (typeof localization === string_type) {
                if (
                  String_ctr[$locale][$to_lowercase]().indexOf(locale) === 0
                ) {
                  localization = request_JSON(localization);
                } else {
                  if (!(locale in load_queues)) {
                    load_queues[locale] = [];
                  }
                  load_queues[locale].push(localization);
                  continue;
                }
              }
              for (message in localization) {
                if (has_own_prop.call(localization, message)) {
                  localizations[locale][message] = localization[message];
                }
              }
            }
          }
        }
      }
      return Function.prototype[$to_locale_string].apply(String_ctr, arguments);
    }),
    process_load_queue = function (locale) {
      var queue = load_queues[locale],
        i = 0,
        len = queue.length,
        localization;
      for (; i < len; i++) {
        localization = {};
        localization[locale] = request_JSON(queue[i]);
        load(localization);
      }
      delete load_queues[locale];
    },
    use_default,
    localize = (String_ctr.prototype[$to_locale_string] = function () {
      if (typeof this === undef_type) {
        return this;
      }
      var using_default = use_default,
        current_locale = String_ctr[using_default ? $default_locale : $locale],
        parts = current_locale[$to_lowercase]().split("-"),
        i = parts.length,
        this_val = this.valueOf(),
        locale;
      use_default = FALSE;
      do {
        locale = parts.slice(0, i).join("-");
        if (locale in load_queues) {
          process_load_queue(locale);
        }
        if (locale in localizations && this_val in localizations[locale]) {
          return localizations[locale][this_val];
        }
      } while (i-- > 1);
      if (!using_default && String_ctr[$default_locale]) {
        use_default = TRUE;
        return localize.call(this_val);
      }
      return this_val;
    });
  if (
    typeof XMLHttpRequest === undef_type &&
    typeof ActiveXObject !== undef_type
  ) {
    var AXO = ActiveXObject;
    XHR = function () {
      try {
        return new AXO("Msxml2.XMLHTTP.6.0");
      } catch (xhrEx1) {}
      try {
        return new AXO("Msxml2.XMLHTTP.3.0");
      } catch (xhrEx2) {}
      try {
        return new AXO("Msxml2.XMLHTTP");
      } catch (xhrEx3) {}
      throw new Error("XMLHttpRequest not supported by this browser.");
    };
  } else {
    XHR = XMLHttpRequest;
  }
  String_ctr[$default_locale] = String_ctr[$default_locale] || "";
  String_ctr[$locale] = (nav && (nav.language || nav.userLanguage)) || "";
  if (typeof document !== undef_type) {
    var elts = document.getElementsByTagName("link"),
      i = elts.length,
      localization;
    while (i--) {
      var elt = elts[i],
        rel = (elt.getAttribute("rel") || "")[$to_lowercase]().split(/\s+/);
      if (l10n_js_media_type.test(elt.type)) {
        if (array_index_of.call(rel, "localizations") !== -1) {
          load(elt.getAttribute("href"));
        } else if (array_index_of.call(rel, "localization") !== -1) {
          localization = {};
          localization[(elt.getAttribute("hreflang") || "")[$to_lowercase]()] =
            elt.getAttribute("href");
          load(localization);
        }
      }
    }
  }
})();
function Localize(key) {
  var string = "%" + key;
  return string.toLocaleString();
}
function LocalizeElement(className) {
  var element = document.getElementsByClassName(className);
  if (element[0]) element[0].innerHTML = Localize(className);
}
String.toLocaleString({
  it: {
    "%game-intro": "Join the <strong>Cupcakes!</strong>",
    "%restart-button": "Play Again",
    "%keep-playing-button": "Keep going",
    "%retry-button": "Retry",
    "%game-won": "You win!",
    "%game-over": "Game over!",
    "%game-explanation":
      '<strong class="important">How to play:</strong> Use your <strong>arrow keys</strong> to move the tiles. When two tiles with the same symbol touch, they <strong>get promoted!</strong>',
    "%disclaimer":
      '<strong class="important">Note:</strong> This site <a href="http://git.io/cupcakes">git.io/cupcakes</a> is a spin-off of the official version of <a href="http://git.io/2048">2048</a> created by <a href="http://gabrielecirulli.com" target="_blank">Gabriele Cirulli</a>.',
    "%credits":
      'Cupcakes images by <a href="http://www.georgetowncupcake.com/" title="Georgetown Cupcake | DC Cupcakes | About">Georgetown Cupcake</a>.',
    "%tweet1": 'I scored "',
    "%tweet2": " at 2048-CUPCAKES #2048game",
    "%tile-legend": '<strong class="important">Tile Legend:</strong>',
    "%2": "vanilla birthday",
    "%4": "bubblegum pink",
    "%8": "sunshine vanilla",
    "%16": "valrhona blonde ganache",
    "%32": "chocolare peanut butter cheesecake",
    "%64": "chocolate mint fudge",
    "%128": "chocolate spider web",
    "%256": "toasted marshmallow",
    "%512": "cookies and creme",
    "%1024": "chocolate sundae",
    "%2048": "white chocolate peppermint",
    "%4096": "2017 Confetti Vanilla",
    "%8192": "Rainbow",
    "%p0": "vanilla birthday",
    "%p4": "bubblegum pink",
    "%p8": "sunshine vanilla",
    "%p16": "valrhona blonde ganache",
    "%p32": "choc. peanut butter cheesecake",
    "%p64": "choc. mint fudge",
    "%p128": "choc. spider web",
    "%p256": "toasted marshmallow",
    "%p512": "cookies and creme",
    "%p1024": "choc. sundae",
    "%p2048": "white choc. peppermint",
    "%p4096": "2017 Confetti Vanilla",
    "%p8192": "Rainbow",
  },
  en: {
    "%game-intro": "Join the <strong>Cupcakes!</strong>",
    "%restart-button": "Play Again",
    "%keep-playing-button": "Keep going",
    "%retry-button": "Retry",
    "%game-won": "You win!",
    "%game-over": "Game over!",
    "%game-explanation":
      '<strong class="important">How to play:</strong> Use your <strong>arrow keys</strong> to move the tiles. When two tiles with the same symbol touch, they <strong>get promoted!</strong>',
    "%disclaimer":
      '<strong class="important">Note:</strong> This site <a href="http://git.io/cupcakes">git.io/cupcakes</a> is a spin-off of the official version of <a href="http://git.io/2048">2048</a> created by <a href="http://gabrielecirulli.com" target="_blank">Gabriele Cirulli</a>.',
    "%credits":
      'Cupcakes images by <a href="http://www.georgetowncupcake.com/" title="Georgetown Cupcake | DC Cupcakes | About">Georgetown Cupcake</a>.',
    "%tweet1": 'I scored "',
    "%tweet2": " at 2048-CUPCAKES #2048game",
    "%tile-legend": '<strong class="important">Tile Legend:</strong>',
    "%2": "vanilla birthday",
    "%4": "bubblegum pink",
    "%8": "sunshine vanilla",
    "%16": "valrhona blonde ganache",
    "%32": "chocolare peanut butter cheesecake",
    "%64": "chocolate mint fudge",
    "%128": "chocolate spider web",
    "%256": "toasted marshmallow",
    "%512": "cookies and creme",
    "%1024": "chocolate sundae",
    "%2048": "white chocolate peppermint",
    "%4096": "2017 Confetti Vanilla",
    "%8192": "Rainbow",
    "%p0": "vanilla birthday",
    "%p4": "bubblegum pink",
    "%p8": "sunshine vanilla",
    "%p16": "valrhona blonde ganache",
    "%p32": "choc. peanut butter cheesecake",
    "%p64": "choc. mint fudge",
    "%p128": "choc. spider web",
    "%p256": "toasted marshmallow",
    "%p512": "cookies and creme",
    "%p1024": "choc. sundae",
    "%p2048": "white choc. peppermint",
    "%p4096": "2017 Confetti Vanilla",
    "%p8192": "Rainbow",
  },
});
function KeyboardInputManager() {
  this.events = {};
  if (window.navigator.msPointerEnabled) {
    this.eventTouchstart = "MSPointerDown";
    this.eventTouchmove = "MSPointerMove";
    this.eventTouchend = "MSPointerUp";
  } else {
    this.eventTouchstart = "touchstart";
    this.eventTouchmove = "touchmove";
    this.eventTouchend = "touchend";
  }
  this.listen();
}
KeyboardInputManager.prototype.on = function (event, callback) {
  if (!this.events[event]) {
    this.events[event] = [];
  }
  this.events[event].push(callback);
};
KeyboardInputManager.prototype.emit = function (event, data) {
  var callbacks = this.events[event];
  if (callbacks) {
    callbacks.forEach(function (callback) {
      callback(data);
    });
  }
};
KeyboardInputManager.prototype.listen = function () {
  var self = this;
  var map = {
    38: 0,
    39: 1,
    40: 2,
    37: 3,
    75: 0,
    76: 1,
    74: 2,
    72: 3,
    87: 0,
    68: 1,
    83: 2,
    65: 3,
  };
  document.addEventListener("keydown", function (event) {
    var modifiers =
      event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
    var mapped = map[event.which];
    if (!modifiers) {
      if (mapped !== undefined) {
        event.preventDefault();
        self.emit("move", mapped);
      }
    }
    if (!modifiers && event.which === 82) {
      self.restart.call(self, event);
    }
  });
  this.bindButtonPress(".retry-button", this.restart);
  this.bindButtonPress(".restart-button", this.restart);
  this.bindButtonPress(".keep-playing-button", this.keepPlaying);
  var touchStartClientX, touchStartClientY;
  var gameContainer = document.getElementsByClassName("game-container")[0];
  gameContainer.addEventListener(this.eventTouchstart, function (event) {
    if (
      (!window.navigator.msPointerEnabled && event.touches.length > 1) ||
      event.targetTouches > 1
    ) {
      return;
    }
    if (window.navigator.msPointerEnabled) {
      touchStartClientX = event.pageX;
      touchStartClientY = event.pageY;
    } else {
      touchStartClientX = event.touches[0].clientX;
      touchStartClientY = event.touches[0].clientY;
    }
    event.preventDefault();
  });
  gameContainer.addEventListener(this.eventTouchmove, function (event) {
    event.preventDefault();
  });
  gameContainer.addEventListener(this.eventTouchend, function (event) {
    if (
      (!window.navigator.msPointerEnabled && event.touches.length > 0) ||
      event.targetTouches > 0
    ) {
      return;
    }
    var touchEndClientX, touchEndClientY;
    if (window.navigator.msPointerEnabled) {
      touchEndClientX = event.pageX;
      touchEndClientY = event.pageY;
    } else {
      touchEndClientX = event.changedTouches[0].clientX;
      touchEndClientY = event.changedTouches[0].clientY;
    }
    var dx = touchEndClientX - touchStartClientX;
    var absDx = Math.abs(dx);
    var dy = touchEndClientY - touchStartClientY;
    var absDy = Math.abs(dy);
    if (Math.max(absDx, absDy) > 10) {
      self.emit("move", absDx > absDy ? (dx > 0 ? 1 : 3) : dy > 0 ? 2 : 0);
    }
  });
};
KeyboardInputManager.prototype.restart = function (event) {
  event.preventDefault();
  this.emit("restart");
};
KeyboardInputManager.prototype.keepPlaying = function (event) {
  event.preventDefault();
  this.emit("keepPlaying");
};
KeyboardInputManager.prototype.crowd = function (event) {
  event.preventDefault();
  this.emit("crowd");
};
KeyboardInputManager.prototype.bindButtonPress = function (selector, fn) {
  var button = document.querySelector(selector);
  button.addEventListener("click", fn.bind(this));
  button.addEventListener(this.eventTouchend, fn.bind(this));
};
function HTMLActuator() {
  this.tileContainer = document.querySelector(".tile-container");
  this.scoreContainer = document.querySelector(".score-container");
  this.scorePoints = document.querySelector(".score-points");
  this.bestContainer = document.querySelector(".best-container");
  this.bestPoints = document.querySelector(".best-points");
  this.messageContainer = document.querySelector(".game-message");
  this.sharingContainer = document.querySelector(".score-sharing");
  this.score = 0;
  this.points = 0;
}
HTMLActuator.prototype.actuate = function (grid, metadata) {
  var self = this;
  window.requestAnimationFrame(function () {
    self.clearContainer(self.tileContainer);
    grid.cells.forEach(function (column) {
      column.forEach(function (cell) {
        if (cell) {
          self.addTile(cell);
        }
      });
    });
    self.updateScore(metadata.score, metadata.points);
    self.updateBestScore(metadata.bestScore, metadata.bestPoints);
    if (metadata.terminated) {
      if (metadata.over) {
        self.message(false);
      } else if (metadata.won) {
        self.message(true);
      }
    }
  });
};
HTMLActuator.prototype.continueGame = function () {
  this.clearMessage();
};
HTMLActuator.prototype.clearContainer = function (container) {
  while (container.firstChild) {
    container.removeChild(container.firstChild);
  }
};
HTMLActuator.prototype.addTile = function (tile) {
  var self = this;
  var wrapper = document.createElement("div");
  var inner = document.createElement("div");
  var img = document.createElement("img");
  var position = tile.previousPosition || { x: tile.x, y: tile.y };
  var positionClass = this.positionClass(position);
  var classes = ["tile", "tile-" + tile.value, positionClass];
  if (tile.value > 2048) classes.push("tile-super");
  this.applyClasses(wrapper, classes);
  inner.classList.add("tile-inner");
  img.src = "style/img/" + tile.value + ".jpg";
  inner.appendChild(img);
  if (tile.previousPosition) {
    window.requestAnimationFrame(function () {
      classes[2] = self.positionClass({ x: tile.x, y: tile.y });
      self.applyClasses(wrapper, classes);
    });
  } else if (tile.mergedFrom) {
    classes.push("tile-merged");
    this.applyClasses(wrapper, classes);
    tile.mergedFrom.forEach(function (merged) {
      self.addTile(merged);
    });
  } else {
    classes.push("tile-new");
    this.applyClasses(wrapper, classes);
  }
  wrapper.appendChild(inner);
  this.tileContainer.appendChild(wrapper);
};
HTMLActuator.prototype.applyClasses = function (element, classes) {
  element.setAttribute("class", classes.join(" "));
};
HTMLActuator.prototype.normalizePosition = function (position) {
  return { x: position.x + 1, y: position.y + 1 };
};
HTMLActuator.prototype.positionClass = function (position) {
  position = this.normalizePosition(position);
  return "tile-position-" + position.x + "-" + position.y;
};
HTMLActuator.prototype.updateScore = function (score, points) {
  this.clearContainer(this.scoreContainer);
  this.clearContainer(this.scorePoints);
  var difference = score - this.score;
  this.score = score;
  var pointDifference = points - this.points;
  this.points = points;
  this.scorePoints.textContent = this.points;
  this.scoreContainer.textContent = Localize("p" + this.score);
  if (difference > 0) {
    var addition = document.createElement("div");
    addition.classList.add("score-addition");
    addition.textContent = Localize("p" + this.score);
    this.scoreContainer.appendChild(addition);
  }
  if (pointDifference > 0) {
    var punti = document.createElement("div");
    punti.classList.add("score-addition");
    punti.textContent = "+" + pointDifference;
    this.scorePoints.appendChild(punti);
  }
};
HTMLActuator.prototype.updateBestScore = function (bestScore, bestPoints) {
  this.bestContainer.textContent = Localize("p" + bestScore);
  this.bestPoints.textContent = bestPoints;
};
HTMLActuator.prototype.message = function (won) {
  var type = won ? "game-won" : "game-over";
  var message = Localize(type);
  this.messageContainer.classList.add(type);
  this.messageContainer.getElementsByTagName("p")[0].textContent = message;
  this.clearContainer(this.sharingContainer);
  this.sharingContainer.appendChild(this.scoreTweetButton());
  twttr.widgets.load();
};
HTMLActuator.prototype.clearMessage = function () {
  this.messageContainer.classList.remove("game-won");
  this.messageContainer.classList.remove("game-over");
};
function Grid(size, previousState) {
  this.size = size;
  this.cells = previousState ? this.fromState(previousState) : this.empty();
}
Grid.prototype.empty = function () {
  var cells = [];
  for (var x = 0; x < this.size; x++) {
    var row = (cells[x] = []);
    for (var y = 0; y < this.size; y++) {
      row.push(null);
    }
  }
  return cells;
};
Grid.prototype.fromState = function (state) {
  var cells = [];
  for (var x = 0; x < this.size; x++) {
    var row = (cells[x] = []);
    for (var y = 0; y < this.size; y++) {
      var tile = state[x][y];
      row.push(tile ? new Tile(tile.position, tile.value) : null);
    }
  }
  return cells;
};
Grid.prototype.randomAvailableCell = function () {
  var cells = this.availableCells();
  if (cells.length) {
    return cells[Math.floor(Math.random() * cells.length)];
  }
};
Grid.prototype.availableCells = function () {
  var cells = [];
  this.eachCell(function (x, y, tile) {
    if (!tile) {
      cells.push({ x: x, y: y });
    }
  });
  return cells;
};
Grid.prototype.eachCell = function (callback) {
  for (var x = 0; x < this.size; x++) {
    for (var y = 0; y < this.size; y++) {
      callback(x, y, this.cells[x][y]);
    }
  }
};
Grid.prototype.cellsAvailable = function () {
  return !!this.availableCells().length;
};
Grid.prototype.cellAvailable = function (cell) {
  return !this.cellOccupied(cell);
};
Grid.prototype.cellOccupied = function (cell) {
  return !!this.cellContent(cell);
};
Grid.prototype.cellContent = function (cell) {
  if (this.withinBounds(cell)) {
    return this.cells[cell.x][cell.y];
  } else {
    return null;
  }
};
Grid.prototype.insertTile = function (tile) {
  this.cells[tile.x][tile.y] = tile;
};
Grid.prototype.removeTile = function (tile) {
  this.cells[tile.x][tile.y] = null;
};
Grid.prototype.withinBounds = function (position) {
  return (
    position.x >= 0 &&
    position.x < this.size &&
    position.y >= 0 &&
    position.y < this.size
  );
};
Grid.prototype.serialize = function () {
  var cellState = [];
  for (var x = 0; x < this.size; x++) {
    var row = (cellState[x] = []);
    for (var y = 0; y < this.size; y++) {
      row.push(this.cells[x][y] ? this.cells[x][y].serialize() : null);
    }
  }
  return { size: this.size, cells: cellState };
};
function Tile(position, value) {
  this.x = position.x;
  this.y = position.y;
  this.value = value || 2;
  this.previousPosition = null;
  this.mergedFrom = null;
}
Tile.prototype.savePosition = function () {
  this.previousPosition = { x: this.x, y: this.y };
};
Tile.prototype.updatePosition = function (position) {
  this.x = position.x;
  this.y = position.y;
};
Tile.prototype.serialize = function () {
  return { position: { x: this.x, y: this.y }, value: this.value };
};
window.fakeStorage = {
  _data: {},
  setItem: function (id, val) {
    return (this._data[id] = String(val));
  },
  getItem: function (id) {
    return this._data.hasOwnProperty(id) ? this._data[id] : undefined;
  },
  removeItem: function (id) {
    return delete this._data[id];
  },
  clear: function () {
    return (this._data = {});
  },
};
function LocalStorageManager() {
  this.bestScoreKey = "bestScoreCupcakes";
  this.bestPointsKey = "bestPointsCupcakes";
  this.gameStateKey = "gameStateCupcakes";
  var supported = this.localStorageSupported();
  this.storage = supported ? window.localStorage : window.fakeStorage;
}
LocalStorageManager.prototype.localStorageSupported = function () {
  var testKey = "test";
  var storage = window.localStorage;
  try {
    storage.setItem(testKey, "1");
    storage.removeItem(testKey);
    return true;
  } catch (error) {
    return false;
  }
};
LocalStorageManager.prototype.getBestScore = function () {
  return this.storage.getItem(this.bestScoreKey) || 0;
};
LocalStorageManager.prototype.setBestScore = function (score) {
  this.storage.setItem(this.bestScoreKey, score);
};
LocalStorageManager.prototype.getBestPoints = function () {
  return this.storage.getItem(this.bestPointsKey) || 0;
};
LocalStorageManager.prototype.setBestPoints = function (points) {
  this.storage.setItem(this.bestPointsKey, points);
};
LocalStorageManager.prototype.getGameState = function () {
  var stateJSON = this.storage.getItem(this.gameStateKey);
  return stateJSON ? JSON.parse(stateJSON) : null;
};
LocalStorageManager.prototype.setGameState = function (gameState) {
  this.storage.setItem(this.gameStateKey, JSON.stringify(gameState));
};
LocalStorageManager.prototype.clearGameState = function () {
  this.storage.removeItem(this.gameStateKey);
};
function GameManager(size, InputManager, Actuator, StorageManager) {
  this.size = size;
  this.inputManager = new InputManager();
  this.storageManager = new StorageManager();
  this.actuator = new Actuator();
  this.startTiles = 2;
  this.inputManager.on("move", this.move.bind(this));
  this.inputManager.on("restart", this.restart.bind(this));
  this.inputManager.on("keepPlaying", this.keepPlaying.bind(this));
  this.setup();
}
function kcal(exp) {
  var kcal = [];
  kcal[2] = 200;
  kcal[4] = 250;
  kcal[8] = 320;
  kcal[16] = 400;
  kcal[32] = 500;
  kcal[64] = 650;
  kcal[128] = 820;
  kcal[256] = 1000;
  kcal[512] = 1200;
  kcal[1024] = 1500;
  kcal[2048] = 2000;
  kcal[4096] = 3000;
  kcal[8192] = 5000;
  return kcal[exp];
}
GameManager.prototype.restart = function () {
  this.storageManager.clearGameState();
  this.actuator.continueGame();
  this.setup();
};
GameManager.prototype.crowd = function () {
  this.storageManager.clearGameState();
  this.actuator.continueGame();
  this.grid = new Grid(this.size);
  this.score = 0;
  this.points = 0;
  this.over = false;
  this.won = false;
  this.keepPlaying = false;
  this.actuate();
  var counter = 0;
  for (var i = 0; i < 3; i++) {
    for (var j = 0; j < 4; j++) {
      counter++;
      var value = Math.pow(2, counter);
      var tile = new Tile({ x: j, y: i }, value);
      if (value <= 8192) this.grid.insertTile(tile);
    }
  }
};
GameManager.prototype.keepPlaying = function () {
  this.keepPlaying = true;
  this.actuator.continueGame();
};
GameManager.prototype.isGameTerminated = function () {
  if (this.over || (this.won && !this.keepPlaying)) {
    return true;
  } else {
    return false;
  }
};
GameManager.prototype.setup = function () {
  var previousState = this.storageManager.getGameState();
  if (previousState) {
    this.grid = new Grid(previousState.grid.size, previousState.grid.cells);
    this.score = previousState.score;
    this.points = previousState.points;
    this.over = previousState.over;
    this.won = previousState.won;
    this.keepPlaying = previousState.keepPlaying;
  } else {
    this.grid = new Grid(this.size);
    this.score = 0;
    this.points = 0;
    this.over = false;
    this.won = false;
    this.keepPlaying = false;
    this.addStartTiles();
  }
  this.localizeElements();
  this.fillLegend();
  this.actuate();
};
GameManager.prototype.localizeElements = function () {
  var elementArray = [
    "game-intro",
    "restart-button",
    "retry-button",
    "keep-playing-button",
    "game-explanation",
    "disclaimer",
    "tile-legend",
    "credits",
  ];
  for (var i in elementArray) {
    LocalizeElement(elementArray[i]);
  }
};
GameManager.prototype.fillLegend = function () {
  var legend = document.getElementsByClassName("tile-legend");
  for (var i = 1; i <= 13; i++) {
    var exp = Math.pow(2, i);
    var row = document.createElement("div");
    var grid = document.createElement("div");
    var cell = document.createElement("div");
    var img = document.createElement("img");
    var p = document.createElement("p");
    row.classList.add("legend-row");
    grid.classList.add("legend-grid");
    cell.classList.add("legend-cell");
    cell.classList.add("cell-" + exp);
    img.src = "style/img/" + exp + ".jpg";
    cell.appendChild(img);
    grid.appendChild(cell);
    row.appendChild(grid);
    p.textContent = Localize(exp) + "  (" + kcal(exp) + " Kcal)";
    row.appendChild(p);
    legend[0].appendChild(row);
  }
};
GameManager.prototype.addStartTiles = function () {
  for (var i = 0; i < this.startTiles; i++) {
    this.addRandomTile();
  }
};
GameManager.prototype.addRandomTile = function () {
  if (this.grid.cellsAvailable()) {
    var value = Math.random() < 0.9 ? 2 : 4;
    var tile = new Tile(this.grid.randomAvailableCell(), value);
    this.grid.insertTile(tile);
  }
};
GameManager.prototype.actuate = function () {
  if (this.storageManager.getBestScore() < this.score) {
    this.storageManager.setBestScore(this.score);
  }
  if (this.storageManager.getBestPoints() < this.points) {
    this.storageManager.setBestPoints(this.points);
  }
  if (this.over) {
    this.storageManager.clearGameState();
  } else {
    this.storageManager.setGameState(this.serialize());
  }
  this.actuator.actuate(this.grid, {
    score: this.score,
    points: this.points,
    over: this.over,
    won: this.won,
    bestScore: this.storageManager.getBestScore(),
    bestPoints: this.storageManager.getBestPoints(),
    terminated: this.isGameTerminated(),
  });
};
GameManager.prototype.serialize = function () {
  return {
    grid: this.grid.serialize(),
    score: this.score,
    points: this.points,
    over: this.over,
    won: this.won,
    keepPlaying: this.keepPlaying,
  };
};
GameManager.prototype.prepareTiles = function () {
  this.grid.eachCell(function (x, y, tile) {
    if (tile) {
      tile.mergedFrom = null;
      tile.savePosition();
    }
  });
};
GameManager.prototype.moveTile = function (tile, cell) {
  this.grid.cells[tile.x][tile.y] = null;
  this.grid.cells[cell.x][cell.y] = tile;
  tile.updatePosition(cell);
};
GameManager.prototype.move = function (direction) {
  var self = this;
  if (this.isGameTerminated()) return;
  var cell, tile;
  var vector = this.getVector(direction);
  var traversals = this.buildTraversals(vector);
  var moved = false;
  this.prepareTiles();
  traversals.x.forEach(function (x) {
    traversals.y.forEach(function (y) {
      cell = { x: x, y: y };
      tile = self.grid.cellContent(cell);
      if (tile) {
        var positions = self.findFarthestPosition(cell, vector);
        var next = self.grid.cellContent(positions.next);
        if (next && next.value === tile.value && !next.mergedFrom) {
          var merged = new Tile(positions.next, tile.value * 2);
          merged.mergedFrom = [tile, next];
          self.grid.insertTile(merged);
          self.grid.removeTile(tile);
          tile.updatePosition(positions.next);
          self.points += kcal(tile.value) * 2;
          if (merged.value > self.score) self.score = merged.value;
          if (merged.value === 2048 || merged.value === 2048) self.won = true;
        } else {
          self.moveTile(tile, positions.farthest);
        }
        if (!self.positionsEqual(cell, tile)) {
          moved = true;
        }
      }
    });
  });
  if (moved) {
    this.addRandomTile();
    if (!this.movesAvailable()) {
      this.over = true;
    }
    this.actuate();
  }
};
GameManager.prototype.getVector = function (direction) {
  var map = {
    0: { x: 0, y: -1 },
    1: { x: 1, y: 0 },
    2: { x: 0, y: 1 },
    3: { x: -1, y: 0 },
  };
  return map[direction];
};
GameManager.prototype.buildTraversals = function (vector) {
  var traversals = { x: [], y: [] };
  for (var pos = 0; pos < this.size; pos++) {
    traversals.x.push(pos);
    traversals.y.push(pos);
  }
  if (vector.x === 1) traversals.x = traversals.x.reverse();
  if (vector.y === 1) traversals.y = traversals.y.reverse();
  return traversals;
};
GameManager.prototype.findFarthestPosition = function (cell, vector) {
  var previous;
  do {
    previous = cell;
    cell = { x: previous.x + vector.x, y: previous.y + vector.y };
  } while (this.grid.withinBounds(cell) && this.grid.cellAvailable(cell));
  return { farthest: previous, next: cell };
};
GameManager.prototype.movesAvailable = function () {
  return this.grid.cellsAvailable() || this.tileMatchesAvailable();
};
GameManager.prototype.tileMatchesAvailable = function () {
  var self = this;
  var tile;
  for (var x = 0; x < this.size; x++) {
    for (var y = 0; y < this.size; y++) {
      tile = this.grid.cellContent({ x: x, y: y });
      if (tile) {
        for (var direction = 0; direction < 4; direction++) {
          var vector = self.getVector(direction);
          var cell = { x: x + vector.x, y: y + vector.y };
          var other = self.grid.cellContent(cell);
          if (other && other.value === tile.value) {
            return true;
          }
        }
      }
    }
  }
  return false;
};
GameManager.prototype.positionsEqual = function (first, second) {
  return first.x === second.x && first.y === second.y;
};
window.requestAnimationFrame(function () {
  new GameManager(4, KeyboardInputManager, HTMLActuator, LocalStorageManager);
});
